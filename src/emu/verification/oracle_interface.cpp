#include "oracle_interface.h"
#include <solvers/smt2/smt2_dec.h>
#include <langapi/language_util.h>




void oracle_interfacet::add_problem(const problemt &problem, const solutiont &solution, decision_proceduret &solver)
{
  verify_encodingt::check_function_bodies(solution.functions);
  verify_encoding.functions = solution.functions;
  verify_encoding.free_variables = problem.free_variables;
  
  verify_encoding.clear();
  const exprt encoded_assumptions = verify_encoding(conjunction(problem.assumptions));
  solver.set_to_true(encoded_assumptions);
  const exprt encoded_constraints = verify_encoding(conjunction(problem.constraints));
  solver.set_to_false(encoded_constraints);
}


int evaluate_expr(const exprt &expr)
{
  INVARIANT(expr.type().id()==ID_bitvector || expr.type().id()==ID_integer, "can only evaluate integer or bitvec exprs")


}

std::vector<std::vector<exprt>> find_synth_fun(const exprt &expr, const problemt &problem)
{
  std::vector<std::vector<exprt>> result;

  if(expr.id()==ID_mathematical_function)
  {
    auto tmp=to_function_application_expr(expr);
    if(problem.synthesis_functions.find(tmp.function().id())!=problem.synthesis_functions.end())
    {
      result.push_back(tmp.arguments());
    }
  }
}

std::set<irep_idt> oracle_interfacet::find_synth_funs (const exprt &expr, const problemt &problem)
{
  std::set<irep_idt> synthfuns;
  if(expr.id()==ID_mathematical_function)
  {
    auto tmp=to_function_application_expr(expr);
    irep_idt id = to_symbol_expr(tmp.function()).id();
    if(problem.synthesis_functions.find(id)!=problem.synthesis_functions.end())
    {
    // if constraint contains synth funs called with complicated expressions rather than
    // plain variables from the input signature, throw unsuppored error. 
      for(const auto & arg: tmp.arguments())
        if(arg.id()!=ID_symbol)
          throw error ("synth fun called with unsupported expression in constraint");
      result.push_back(id);
    }
  }
  for(const auto &op: expr.operands())
    for(const auto &id: find_synth_funs(op, problem))
    result.push_back(id);
  return result;
}


void oracle_interfacet::set_up_oracles(const problemt &problem)
{

  for(std::size_t idx=0; idx<problem.oracle_constraint_gens.size(); idx++)
  {
    auto &oracle = problem.oracle_constraint_gens[idx];
    // find synth fun in the problem and get arguments
    // if constraint contains more than one synth fun, throw unsupported error
    std::set<irep_idt> synthfuns=find_synth_funs(oracle.constraint, problem);
    if(synthfuns.size()>1)
      throw error("more than one synth fun in constraint is not yet supported");
    synthfun_to_constraint_map[synthfuns.begin()]=idx;  






  }





}

void oracle_interfacet::call_oracles(problemt &problem, 
const solutiont &solution, const counterexamplet &counterexample)
{
  // pick some strategy to call them? or just call them all
  for(const auto &cons: problem.oracle_constraint_gens)
    call_oracle_constraint();

  for(const auto &cons: problem.oracle_assumption_gens)
    call_oracle_assumption();
}

oracle_interfacet::resultt oracle_interfacet::operator()(problemt &problem,
                                                         const solutiont &solution)
{
  // get solver
  smt2_dect subsolver(
      ns, "fastsynth", "generated by fastsynth",
      "LIA", smt2_dect::solvert::Z3, message_handler);
   oracle_solvert oracle_solver(subsolver, problem.oracle_constraint_gens, message_handler);   

  return this->operator()(problem, solution, oracle_solver);
}

oracle_interfacet::resultt oracle_interfacet::operator()(problemt &problem,
    const solutiont &solution,
    decision_proceduret &solver)
  {
    // do something with the model? 
    add_problem(problem, solution, solver);
    decision_proceduret::resultt result = solver();

    switch(result)
    {
      case decision_proceduret::resultt::D_SATISFIABLE:
      {
        counterexample=
        verify_encoding.get_counterexample(solver);
        call_oracles(problem);
        return oracle_interfacet::resultt::FAIL; 
      }
      case decision_proceduret::resultt::D_ERROR:
      {
        call_oracles(problem);
        return oracle_interfacet::resultt::FAIL;
      } 
      case decision_proceduret::resultt::D_UNSATISFIABLE:
      {
        counterexample.clear();
      return oracle_interfacet::resultt::PASS;
      }
    }
  }

counterexamplet oracle_interfacet::get_counterexample()
{
  return counterexample;
}  