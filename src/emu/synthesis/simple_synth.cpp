#include "simple_synth.h"
#include <solvers/smt2/smt2_dec.h>
#include <util/mathematical_expr.h>
#include "../expr2sygus.h"

void simple_syntht::add_problem(synth_encodingt &encoding, decision_proceduret &solver, const problemt &problem)
{
  exprt true_expr = true_exprt();
  exprt& synthesis_assumptions = true_expr;
  switch (problem.synthesis_assumptions.size())
  {
  case 0:
    break;
  case 1:
    synthesis_assumptions = problem.synthesis_assumptions[0];
    break;
  default:
    synthesis_assumptions = or_exprt(problem.synthesis_assumptions);
  }

  exprt& assumptions = true_expr;
  switch (problem.assumptions.size())
  {
  case 0:
    break;
  case 1:
    assumptions = problem.assumptions[0];
    break;
  default:
    assumptions = and_exprt(problem.assumptions);
  }

  exprt& constraints = true_expr;
  switch (problem.constraints.size())
  {
  case 0:
    break;
  case 1:
    constraints = problem.constraints[0];
    break;
  default:
    constraints = and_exprt(problem.constraints);
  }

  implies_exprt implies_expr(synthesis_assumptions,
                             implies_exprt(assumptions, constraints));
  quantifier_exprt full_problem(ID_forall, problem.synthesis_variables, implies_expr);
  std::cout << expr2sygus(full_problem) << std::endl;
  const exprt encoded = encoding(full_problem);
  solver.set_to_true(encoded);
}

simple_syntht::resultt simple_syntht::operator()(const problemt &problem)
{
  // get solver
  smt2_dect solver(
      ns, "fastsynth", "generated by fastsynth",
      logic, smt2_dect::solvert::Z3, message_handler);

  return this->operator()(problem, solver);
}

simple_syntht::resultt simple_syntht::operator()(const problemt &problem, decision_proceduret &solver)
{
  // add the problem to the solver (synthesis_assumptions => (assumptions => constraints))
  synth_encoding.program_size = 1;
  synth_encoding.enable_bitwise = false;
  add_problem(synth_encoding, solver, problem);

  // solve
  const decision_proceduret::resultt result = solver();
  switch (result)
  {
  case decision_proceduret::resultt::D_SATISFIABLE:
    last_solution = synth_encoding.get_solution(solver);
    return simple_syntht::resultt::CANDIDATE;
  case decision_proceduret::resultt::D_UNSATISFIABLE:
  case decision_proceduret::resultt::D_ERROR:
    return simple_syntht::resultt::NO_SOLUTION;
  }
}

exprt simple_syntht::model(exprt) const
{
  return nil_exprt();
}