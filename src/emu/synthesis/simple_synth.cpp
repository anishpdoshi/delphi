#include "simple_synth.h"
#include <solvers/smt2/smt2_dec.h>
#include <util/mathematical_expr.h>
#include "../expr2sygus.h"

bool contains_oracle(exprt expr, const problemt &problem)
{
  if (expr.type().id() == ID_mathematical_function && 
      problem.synthesis_functions.find(to_symbol_expr(expr).get_identifier())==
      problem.synthesis_functions.end())
  {
    return true;
  } 
  else
  {
    forall_operands(it, expr) 
      if(contains_oracle(*it, problem))
        return true;
  }
  return false;
}

exprt join_expressions(const std::vector<exprt> &expressions, irep_idt id, const problemt &problem)
{
  INVARIANT(id == ID_or || id == ID_and, "expected ID_and or ID_or for join expressions");
  switch (expressions.size())
  {
  case 0:
    return true_exprt();
  case 1:
    return contains_oracle(expressions[0], problem) ? true_exprt() : expressions[0];
  default:
    std::set<std::size_t> indices;
    for (std::size_t i = 0; i < expressions.size(); i++)
      if (contains_oracle(expressions[i], problem))
        indices.insert(i);

    if (indices.size() == 0)
      if (id == ID_or) 
        return or_exprt(expressions);
      else
        return and_exprt(expressions);
    else
    {
      std::vector<exprt> copy_of_expressions;
      for (std::size_t i = 0; i < expressions.size(); i++)
      {
        if(indices.find(i)==indices.end())
          copy_of_expressions.push_back(expressions[i]);
      }
      switch (copy_of_expressions.size())
      {
      case 0:
        return true_exprt();
      case 1:
        return copy_of_expressions[0];
      default:
        if (id == ID_or) 
          return or_exprt(copy_of_expressions);
        else 
          return and_exprt(copy_of_expressions);
      }
    }
  }
}

void simple_syntht::add_problem(synth_encodingt &encoding, decision_proceduret &solver, const problemt &problem)
{
  
  implies_exprt implies_expr(join_expressions(problem.synthesis_assumptions, ID_or, problem),
                             implies_exprt(join_expressions(problem.assumptions, ID_and, problem), 
                             join_expressions(problem.constraints, ID_and, problem)));
  quantifier_exprt full_problem(ID_forall, problem.synthesis_variables, implies_expr);
  std::cout << expr2sygus(full_problem) << std::endl;
  const exprt encoded = encoding(full_problem);
  solver.set_to_true(encoded);
}

simple_syntht::resultt simple_syntht::operator()(const problemt &problem)
{
  // get solver
  smt2_dect solver(
      ns, "fastsynth", "generated by fastsynth",
      logic, smt2_dect::solvert::Z3, message_handler);

  return this->operator()(problem, solver);
}

simple_syntht::resultt simple_syntht::operator()(const problemt &problem, decision_proceduret &solver)
{
  // add the problem to the solver (synthesis_assumptions => (assumptions => constraints))
  synth_encoding.program_size = 1;
  synth_encoding.enable_bitwise = false;
  add_problem(synth_encoding, solver, problem);

  // solve
  const decision_proceduret::resultt result = solver();
  switch (result)
  {
  case decision_proceduret::resultt::D_SATISFIABLE:
    last_solution = synth_encoding.get_solution(solver);
    return simple_syntht::resultt::CANDIDATE;
  case decision_proceduret::resultt::D_UNSATISFIABLE:
  case decision_proceduret::resultt::D_ERROR:
    return simple_syntht::resultt::NO_SOLUTION;
  }
}

exprt simple_syntht::model(exprt) const
{
  return nil_exprt();
}